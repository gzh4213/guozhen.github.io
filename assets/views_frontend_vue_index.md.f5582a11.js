import{_ as s,o as a,c as n,M as l}from"./chunks/framework.3d15f885.js";const D=JSON.parse('{"title":"指南","description":"","frontmatter":{},"headers":[],"relativePath":"views/frontend/vue/index.md","filePath":"views/frontend/vue/index.md","lastUpdated":1700905769000}'),e={name:"views/frontend/vue/index.md"},p=l(`<h1 id="指南" tabindex="-1">指南 <a class="header-anchor" href="#指南" aria-label="Permalink to &quot;指南&quot;">​</a></h1><p><a href="https://cn.vuejs.org/" target="_blank" rel="noreferrer">vue3 官方文档</a></p><p>MVVM(Model-View-ViewModel)架构</p><ol><li>View: 视图层</li><li>ViewModel: 业务逻辑层（一切js可视为业务逻辑）</li><li>Model: 数据层（存储数据及对数据的处理如增删改查）</li></ol><h2 id="vue2-vs-vue3" tabindex="-1">Vue2 VS Vue3 <a class="header-anchor" href="#vue2-vs-vue3" aria-label="Permalink to &quot;Vue2 VS Vue3&quot;">​</a></h2><ul><li>选项时API 逻辑比较分散，可读性差，可维护性差</li><li>组合式API 逻辑分明，可维护性高</li></ul><h2 id="vue3-新特性" tabindex="-1">Vue3 新特性 <a class="header-anchor" href="#vue3-新特性" aria-label="Permalink to &quot;Vue3 新特性&quot;">​</a></h2><h3 id="重写双向数据绑定" tabindex="-1">重写双向数据绑定 <a class="header-anchor" href="#重写双向数据绑定" aria-label="Permalink to &quot;重写双向数据绑定&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// vue2</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 基于Object.defineProperty()实现</span></span>
<span class="line"><span style="color:#BABED8;"> </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// vue3 基于Proxy</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// proxy与Object.defineProperty(obj, prop, desc)方式相比有以下优势：</span></span>
<span class="line"><span style="color:#BABED8;"> </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//丢掉麻烦的备份数据</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//省去for in 循环</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//可以监听数组变化</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//代码更简化</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//可以监听动态新增的属性；</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//可以监听删除的属性 ；</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//可以监听数组的索引和 length 属性；</span></span>
<span class="line"><span style="color:#BABED8;"> </span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> proxyObj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#BABED8;">(obj</span><span style="color:#89DDFF;">,{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#82AAFF;">get</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;">prop</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">prop</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">in</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">target</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">?</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">target</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">prop</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#82AAFF;">set</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;">value</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">target</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">prop</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">888</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="vdom性能瓶颈" tabindex="-1">VDOM性能瓶颈 <a class="header-anchor" href="#vdom性能瓶颈" aria-label="Permalink to &quot;VDOM性能瓶颈&quot;">​</a></h3><p>在Vue2中,每次更新diff,都是全量对比,Vue3则只对比带有标记的,这样大大减少了非动态内容的对比消耗</p><p><a href="https://vue-next-template-explorer.netlify.app/" target="_blank" rel="noreferrer">Vue Template Explorer</a> 可以通过这个网站看到静态标记</p><p>新增 patch flag 标记</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#babed8;">TEXT = 1 // 动态文本节点</span></span>
<span class="line"><span style="color:#babed8;">CLASS=1&lt;&lt;1,1 // 2//动态class</span></span>
<span class="line"><span style="color:#babed8;">STYLE=1&lt;&lt;2，// 4 //动态style</span></span>
<span class="line"><span style="color:#babed8;">PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span></span>
<span class="line"><span style="color:#babed8;">FULLPR0PS=1&lt;&lt;4,// 16 //具有动态key属性，当key改变时，需要进行完整的diff比较。</span></span>
<span class="line"><span style="color:#babed8;">HYDRATE_ EVENTS = 1 &lt;&lt; 5，// 32 //带有监听事件的节点</span></span>
<span class="line"><span style="color:#babed8;">STABLE FRAGMENT = 1 &lt;&lt; 6, // 64 //一个不会改变子节点顺序的fragment</span></span>
<span class="line"><span style="color:#babed8;">KEYED_ FRAGMENT = 1 &lt;&lt; 7, // 128 //带有key属性的fragment 或部分子字节有key</span></span>
<span class="line"><span style="color:#babed8;">UNKEYED FRAGMENT = 1&lt;&lt; 8, // 256 //子节点没有key 的fragment</span></span>
<span class="line"><span style="color:#babed8;">NEED PATCH = 1 &lt;&lt; 9, // 512 //一个节点只会进行非props比较</span></span>
<span class="line"><span style="color:#babed8;">DYNAMIC_SLOTS = 1 &lt;&lt; 10 // 1024 // 动态slot</span></span>
<span class="line"><span style="color:#babed8;">HOISTED = -1 // 静态节点</span></span>
<span class="line"><span style="color:#babed8;">BALL = -2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="fragments" tabindex="-1">Fragments <a class="header-anchor" href="#fragments" aria-label="Permalink to &quot;Fragments&quot;">​</a></h3><ul><li>Vue3允许我们支持多个根节点</li><li>支持render JSX写法</li><li>同时新增了Suspense 和 多v-model用法</li></ul><h3 id="tree-shaking" tabindex="-1">Tree-Shaking <a class="header-anchor" href="#tree-shaking" aria-label="Permalink to &quot;Tree-Shaking&quot;">​</a></h3><p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p><p>在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p><p>而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果你不使用其某些功能，它们将不会包含在你的基础包中</p><p>就是比如你要用watch 就是import {watch} from &#39;vue&#39; 其他的computed 没用到就不会给你打包减少体积</p>`,21),o=[p];function t(r,c,i,y,b,u){return a(),n("div",null,o)}const F=s(e,[["render",t]]);export{D as __pageData,F as default};
